// Processing Template for Zoetrope toy by Eye Think
// https://www.amazon.com/Zoetrope-Animation-Toy-Victorian-Illusion/dp/B007VM9HZO/
// Developed for Processing 3.3.6 * http://processing.org
// 24 January 2018 *Â Golan Levin 

// See information about Processing PDF export at: 
// https://processing.org/reference/libraries/pdf/index.html
// PDF generated by Processing can be opened in Adobe Illustrator.
import processing.pdf.*;
boolean bRecordingPDF = false;

float inch = 72; 
float paperStripWidth = inch * 12.625;
float paperStripHeight = inch * 1.3125;
float overlapMargin = inch * 0.4375;
float artAreaWidth = paperStripWidth - overlapMargin;
float artAreaHeight = paperStripHeight;

final int nFrames = 11; 
int myFrameCount = 0;
int exportFrameCount = 0; 
boolean bAnimate = true; 
boolean bExportFrameImages = false;

//-------------------------------------------------------
void setup() {
  size(1224, 792); // 17x11" at 72DPI
  frameRate(15);
  smooth();
} 

//-------------------------------------------------------
void draw() {
  background(240); 
  if (bRecordingPDF) {
    beginRecord(PDF, "zoetrope-output.pdf");
  }

  // Do all the drawing. 
  pushMatrix(); 
  translate(width/2, height/2);
  translate(0-paperStripWidth/2, 0-paperStripHeight/2); 

  drawCutLines(); 
  drawGuides(); 
  drawAllFrames();
  popMatrix();

  if (bExportFrameImages) {
    // If activated, export .PNG frames 
    if (exportFrameCount < nFrames) {
      String filename = "frame_" + nf((exportFrameCount%nFrames), 3) + ".png";
      saveFrame("frames/" + filename);
      println("Saved: " + filename); 
      exportFrameCount++;
      if (exportFrameCount >= nFrames) {
        bExportFrameImages = false;
        exportFrameCount = 0;
      }
    }
  }

  if (bRecordingPDF) {
    endRecord();
    bRecordingPDF = false;
  }
}


//-------------------------------------------------------
void keyPressed() {
  switch (key) {
  case ' ': 
    // Press spacebar to pause/unpause the animation. 
    bAnimate = !bAnimate;
    break;

  case 'p': 
  case 'P':
    // Press 'p' to export a PDF for the Zoetrope. 17x11" paper!
    bRecordingPDF = true; 
    break;

  case 'f': 
  case 'F': 
    // Press 'f' to export .png Frames (to make an animated .GIF)
    myFrameCount = 0; 
    exportFrameCount = 0; 
    bExportFrameImages = true;
    bAnimate = true; 
    break;
  }
}

//-------------------------------------------------------
void drawCutLines() {
  fill(0); 
  textAlign(CENTER, BOTTOM); 
  text("Zoetrope Template", paperStripWidth/2, -20); 

  stroke(0); 
  strokeWeight(1.0);
  noFill(); 
  if (!bRecordingPDF) {
    fill(255);
  }
  rect(0, 0, paperStripWidth, paperStripHeight);
}

//-------------------------------------------------------
void drawGuides() {
  // This function draws the guidelines. 
  // Don't draw these when we're exporting the PDF. 
  if (!bRecordingPDF) {
    float frameSpacing = artAreaWidth / nFrames;
    
    stroke(128); 
    strokeWeight(0.2);
    for (int i=0; i<nFrames; i++) {
      pushMatrix();
      translate(i * frameSpacing, 0);
      rect(0, 0, frameSpacing, artAreaHeight); 
      popMatrix();
    }
  }
}

//-------------------------------------------------------
void drawAllFrames() {
  for (int i=0; i<nFrames; i++) {

    float frameSpacing = artAreaWidth / nFrames;

    pushMatrix();
    translate((i + 0.5) * frameSpacing, 0);

    int whichFrame = i; 
    if (bAnimate) {
      whichFrame = (i+myFrameCount)%nFrames;
    }
    drawArtFrame (whichFrame); 
    // drawArtFrameAlternate (whichFrame); 

    popMatrix();
  }
  myFrameCount++;
}


//-------------------------------------------------------
void drawArtFrame (int whichFrame) { 
  // Draw the artwork for a generic frame of the Zoetrope, 
  // given the framenumber (whichFrame) out of nFrames.

  // Draw the frame number
  fill(0); 
  noStroke(); 
  textAlign(CENTER, CENTER); 
  text (whichFrame, -1, artAreaHeight * 0.20);

  // Draw a pulsating ellipse
  noFill(); 
  stroke(0);
  strokeWeight(1); 
  float t = map(whichFrame, 0, nFrames, 0, 1); 
  float diam = map(cos(t*TWO_PI), -1, 1, artAreaHeight*0.20, artAreaHeight*0.40); 
  ellipse(0, artAreaHeight*0.22, diam, diam*0.75); 

  // Draw some expanding boxes, centered on the local origin
  int nBoxes = 3;
  for (int i=0; i<nBoxes; i++) {
    float F = ((whichFrame + i*nFrames)/(float)nBoxes)%nFrames;
    float rs = map(F, 0, nFrames-1, 0, artAreaHeight * 0.20); 
    float rx = 0; 
    float ry = artAreaHeight * 0.5; 
    float rg = map(F, 0, nFrames, 0, 255); 
    stroke(rg); 
    strokeWeight(1.0);
    rect(rx-rs/2, ry-rs/2, rs, rs);
  }

  // Draw some rotating spokes
  int nSpokes = 7;
  float spokeRadius = artAreaHeight * 0.10;
  for (int i=0; i<nSpokes; i++) {
    float cx = 0; 
    float cy = artAreaHeight * 0.80; 
    float u = 0 - map(whichFrame + i*nFrames, 0, nFrames*nSpokes, 0, 1);
    float sx = cx + spokeRadius * cos(u * TWO_PI); 
    float sy = cy + spokeRadius * sin(u * TWO_PI); 
    stroke(0); 
    strokeWeight(1);
    line (cx, cy, sx, sy);
  }
}

//-------------------------------------------------------
void drawArtFrameAlternate(int whichFrame) { 
  // An alternate drawing test. 
  // Draw a falling object. 

  float chuteHeight = artAreaHeight * 0.85;
  pushMatrix();
  translate(0, (artAreaHeight - chuteHeight)/2.0);

  // Draw a little splat on the frame when it hits the ground. 
  if (whichFrame == (nFrames-1)) {
    stroke(0, 0, 0); 
    strokeWeight(0.5); 
    int nL = 10;
    for (int i=0; i<nL; i++) {
      float a = HALF_PI + map(i, 0, nL-1, 0, TWO_PI);
      float cx = 12 * cos(a);
      float cy = 10 * sin(a); 
      float dx = 16 * cos(a);
      float dy = 13 * sin(a); 
      line (cx, (chuteHeight-5)+cy, dx, (chuteHeight-5)+dy);
    }
  }

  // Draw a little box frame
  fill(255); 
  stroke(0, 0, 0);
  strokeWeight(1); 
  rect(-5, 0, 10, chuteHeight); 

  // Make the puck accelerate downward
  float t = map(whichFrame, 0, nFrames-1, 0, 1); 
  float t2 = pow(t, 2.0); 
  float rh = 8 + whichFrame * 0.5; // wee stretch
  float ry = map(t2, 0, 1, 0, chuteHeight-rh); 

  noStroke(); 
  fill(0, 0, 0);
  rect(-5, ry, 10, rh);
  
  popMatrix(); 
}
